/* Copyright (c) 2016, 2018, Alibaba and/or its affiliates. All rights reserved.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License, version 2.0,
   as published by the Free Software Foundation.

   This program is also distributed with certain software (including
   but not limited to OpenSSL) that is licensed under separate terms,
   as designated in a particular file or component or in included license
   documentation.  The authors of MySQL hereby grant you an additional
   permission to link the program and your derivative works with the
   separately licensed software that they have included with MySQL.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License, version 2.0, for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */

#include "mysql/psi/mysql_memory.h"
#include "mysql/psi/mysql_rwlock.h"

#include "keyring_rds_common.h"
#include "keyring_rds_key_id.h"
#include "keyring_rds_kms_agent.h"
#include "keyring_rds_logger.h"

namespace keyring_rds {

// The lock that protecting plugin (de-)initializing, master key id accessing
mysql_rwlock_t LOCK_keyring_rds;

// PSI memory key id traced in performance_schema
PSI_memory_key key_memory_KEYRING_rds;

// PSI rwlock key
static PSI_rwlock_key key_LOCK_keyring_rds;

#ifdef HAVE_PSI_INTERFACE
static PSI_rwlock_info all_keyring_rds_rwlocks[] = {
    {&key_LOCK_keyring_rds, "LOCK_keyring_rds", 0, 0, PSI_DOCUMENT_ME}};

static PSI_memory_info all_keyring_rds_memory[] = {
    {&key_memory_KEYRING_rds, "KEYRING_RDS", 0, 0, PSI_DOCUMENT_ME}};

/* Register all the PSI */
static void keyring_rds_init_psi_keys(void) {
  const char *category = "keyring_rds";
  int count;

  count = static_cast<int>(array_elements(all_keyring_rds_memory));
  mysql_memory_register(category, all_keyring_rds_memory, count);

  count = static_cast<int>(array_elements(all_keyring_rds_rwlocks));
  mysql_rwlock_register(category, all_keyring_rds_rwlocks, count);
}
#endif

static volatile bool initialized = false;

/**
  Initialization of the plugin
*/
bool keyring_rds_init(void) {
  if (initialized) return true;

#ifdef HAVE_PSI_INTERFACE
  keyring_rds_init_psi_keys();
#endif

  if (mysql_rwlock_init(key_LOCK_keyring_rds, &LOCK_keyring_rds)) return true;

  if (init_key_id_mgr()) {
    mysql_rwlock_destroy(&LOCK_keyring_rds);
    return true;
  }

  initialized = true;
  return false;
}

/**
  De-initialization of the plugin
*/
void keyring_rds_deinit() {
  if (initialized) {
    deinit_key_id_mgr();
    mysql_rwlock_destroy(&LOCK_keyring_rds);
    initialized = false;
  }
}

/**
  Implementation of the internal keyring service interfaces.
*/
class Key_imp : public Key_interface {
 public:
  /**
    We extended its capabilities compared to the original definition:
    1) when the passed key_id is NULL, it returns the latest master key id,
       innodb will initialize s_uuid & master_key_id by calling in this way;
    2) otherwise, it returns the master key content specified by key_id,
       this is the normal way to call.
  */
  bool fetch(const char *key_id, char **key_type,
             const char *user_id MY_ATTRIBUTE((unused)), void **key,
             size_t *key_len) override {
    if (!initialized) return true;

    *key_type = my_strdup(key_memory_KEYRING_rds, "rds-tde", MYF(MY_WME));
    *key = NULL;  // Assume that it will fail

    Lock_helper rdlock(&LOCK_keyring_rds, false);

    if (key_id == NULL)
      return fetch_latest_key_id(key, key_len);
    else
      return fetch_key_of_id(key_id, key, key_len);
  }

  /**
    We changed its capabilities compared to the original definition:
    key_id is no longer specified by caller, the plugin will interact
    with KMS and acquire both key_id and key content.
    That is, the key_id is generated by KMS but not innodb.
  */
  bool generate(const char *key_id MY_ATTRIBUTE((unused)),
                const char *key_type MY_ATTRIBUTE((unused)),
                const char *user_id MY_ATTRIBUTE((unused)),
                size_t key_len MY_ATTRIBUTE((unused))) override {
    if (!initialized) return true;

    Lock_helper wrlock(&LOCK_keyring_rds, true);

    // Interact with KMS to generate a new key, and fetch its id
    char k[MAX_KEY_ID_LENGTH];
    size_t gen_key_len = kms_agent->generate(k, sizeof(k));
    if (gen_key_len == 0) return true;

    // Store the new key id in cache and persist to local file
    Key_string new_key_id(k, gen_key_len);
    if (key_container->store_key_id(new_key_id)) return true;

    return false;
  }

  /**
    Create a iterator to traverse all key IDs
  */
  void iterator_init(void **key_iterator) override {
    *key_iterator = NULL;  // Assume that it will fail

    if (!initialized) return;

    Lock_helper rdlock(&LOCK_keyring_rds, false);

    Keys_iterator *k_it = new Keys_iterator();
    if (k_it == NULL) {
      Logger::log(ERROR_LEVEL, ER_SERVER_OUTOFMEMORY, sizeof(Keys_iterator));
      return;
    }

    k_it->init(key_container);
    *key_iterator = k_it;
  }

  /**
    Destory the iterator
  */
  void iterator_deinit(void *key_iterator) override {
    Keys_iterator *k_it = static_cast<Keys_iterator *>(key_iterator);
    k_it->deinit();
    delete k_it;
  }

  /**
    Fetch the master key id of the current iterator element
  */
  bool iterator_get_key(void *key_iterator, char *key_id,
                        char *user_id) override {
    Keys_iterator *k_it = static_cast<Keys_iterator *>(key_iterator);
    return k_it->get_key(key_id, user_id);
  }

  /**
    Always failing.
    We do not expect this function to be called,
    key data stroed in KMS automatically.
  */
  bool store(const char *key_id MY_ATTRIBUTE((unused)),
             const char *key_type MY_ATTRIBUTE((unused)),
             const char *user_id MY_ATTRIBUTE((unused)),
             const void *key MY_ATTRIBUTE((unused)),
             size_t key_len MY_ATTRIBUTE((unused))) override {
    return true;
  }

  /**
    Always failing.
    Not supported.
  */
  bool remove(const char *key_id MY_ATTRIBUTE((unused)),
              const char *user_id MY_ATTRIBUTE((unused))) override {
    return true;
  }

 private:
  /* Get key from KMS by key id */
  bool fetch_key_of_id(const char *key_id, void **key, size_t *key_len) {
    /* Validating the key_id */
    Key_string check_id(key_id);
    if (!key_container->exist_in_file(check_id)) {
      /**
        There are some bugs, or local key id file damaged,
        but we still try to fetch it from KMS.
      */
      Logger::log(WARNING_LEVEL, "key id %s missed in cache", key_id);
    }

    char *k = keyring_rds_malloc<char *>(AES_KEY_LENGTH);
    if (k == NULL) {
      Logger::log(ERROR_LEVEL, ER_SERVER_OUTOFMEMORY, AES_KEY_LENGTH);
      return true;
    }

    Key_string key_from_cache;
    bool found_in_cache =
        !key_container->get_key_in_cache(check_id, &key_from_cache);

    if (found_in_cache && !validate_cached_key) {
      memcpy(k, key_from_cache.c_str(), key_from_cache.length());
    } else {
      /* Fetch the key content from KMS/Agent */
      if (kms_agent->fetch(key_id, k, AES_KEY_LENGTH) == 0) {
        my_free(k);
        return true;
      }
      Key_string key_from_kms{k, AES_KEY_LENGTH};

      if (found_in_cache) {
        if (key_from_cache != key_from_kms) {
          Logger::log(ERROR_LEVEL,
                      "the cached key is not equal to the key read from kms, "
                      "cached key is %s, kms key is %s",
                      key_from_cache.c_str(), key_from_kms.c_str());
          return true;
        }
      } else {
        /* Cache the kms key into key_map */
        if (key_container->cache_key(key_id, key_from_kms)) {
          return true;
        }
      }
    }

    *key_len = AES_KEY_LENGTH;
    *key = k;
    return false;
  }

  /* Return the latest master key id */
  bool fetch_latest_key_id(void **key, size_t *key_len) {
    const Key_string &cur_id = key_container->get_current();
    if (cur_id.length() == 0) {
      Logger::log(ERROR_LEVEL, "%s", "fetch key id error: generate one first");
      return true;
    }

    /* Memory will be released by caller */
    *key = keyring_rds_malloc<void *>(cur_id.length() + 1);
    if (*key == NULL) {
      Logger::log(ERROR_LEVEL, ER_SERVER_OUTOFMEMORY, cur_id.length() + 1);
      return true;
    }

    *key_len = cur_id.length();
    strcpy(static_cast<char *>(*key), cur_id.c_str());  // Id is of type string
    return false;
  }
};

static Key_imp global_inst;
Key_interface *key_imp = &global_inst;  // Default implementation

}  // namespace keyring_rds
